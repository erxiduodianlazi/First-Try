## list(map(int,input().split())) = [int(x) for x in input().split()] 

```
print "My name is %s and weight is %d kg!" % ('Zara', 21) 
```

| %c   | 格式化字符及其ASCII码                |
| ---- | ------------------------------------ |
| %s   | 格式化字符串                         |
| %d   | 格式化整数                           |
| %u   | 格式化无符号整型                     |
| %o   | 格式化无符号八进制数                 |
| %x   | 格式化无符号十六进制数               |
| %X   | 格式化无符号十六进制数（大写）       |
| %f   | 格式化浮点数字，可指定小数点后的精度 |
| %e   | 用科学计数法格式化浮点数             |
| %E   | 作用同%e，用科学计数法格式化浮点数   |
| %g   | %f和%e的简写                         |
| %G   | %F 和 %E 的简写                      |
| %p   | 用十六进制数格式化变量的地址         |



"{} {}".format("hello", "world")    'hello world'  

 "{0} {1}".format("hello", "world") 'hello world'  

 "{1} {0} {1}".format("hello", "world")  'world hello world'







import math

math.ceil()  ceil  进一法 1.6取2  -1.4取-1

floor 向下取整 

round 四舍五入



Python列表脚本操作符
列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。

如下所示：

Python 表达式	结果	描述
len([1, 2, 3])	3	长度
[1, 2, 3] + [4, 5, 6]	[1, 2, 3, 4, 5, 6]	组合
['Hi!'] * 4	['Hi!', 'Hi!', 'Hi!', 'Hi!']	重复
3 in [1, 2, 3]	True	元素是否存在于列表中
for x in [1, 2, 3]: print x,	1 2 3	迭代





Python列表函数&方法
Python包含以下函数:

序号	函数
1	cmp(list1, list2)
比较两个列表的元素
2	len(list)
列表元素个数
3	max(list)
返回列表元素最大值
4	min(list)
返回列表元素最小值
5	list(seq)
将元组转换为列表





Python包含以下方法:

序号	方法
1	list.append(obj)
在列表末尾添加新的对象
2	list.count(obj)
统计某个元素在列表中出现的次数
3	list.extend(seq)
在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）
4	list.index(obj)
从列表中找出某个值第一个匹配项的索引位置
5	list.insert(index, obj)
将对象插入列表
6	list.pop([index=-1])
移除列表中的一个元素（默认最后一个元素），并且返回该元素的值
7	list.remove(obj)
移除列表中某个值的第一个匹配项
8	list.reverse()
反向列表中元素
9	list.sort(cmp=None, key=None, reverse=False)
对原列表进行排序



按字典方式排序，不考虑大小写。一个个字母比即可 不需要比较所有字母，只要两个字符串中对应相等处的字母不同，即可比较得出结论

按照字典顺序，单词“Thomas”出现在“Thompson”之前



可以直接比较字符串的大小，不用一个一个比较（比较字符串大小本来就是一个一个比较的，这样代码会比较简） 

line1 = input()
line2 = input() 
if line1.lower() > line2.lower(): 
    print(1) 
elif line1.lower() < line2.lower(): 
    print(-1) 
else:                                                                                                                                                                                                                   
    print(0)



If you want more formal information about the lexicographical order (also known as the "dictionary order" or "alphabetical order"), you can visit the following site:

在 Python 中，你可以使用多种方法将一连串输入的字符串分割成一个一个的子字符串。具体的分割方式取决于你希望如何分割这些字符串。以下是几种常见的方法：

### 1. **按空格分割**

如果你的输入字符串是由空格分隔的，你可以使用 `split()` 方法：

```
python复制代码# 示例输入: "apple banana cherry"
input_string = input()  # 用户输入 "apple banana cherry"
substrings = input_string.split()  # 默认按空格分割
print(substrings)  # 输出: ['apple', 'banana', 'cherry']
```

### 2. **按特定字符分割**

如果你想按其他特定字符（例如逗号、分号等）分割字符串，可以在 `split()` 方法中传入分隔符：

```
python复制代码# 示例输入: "apple,banana,cherry"
input_string = input()  # 用户输入 "apple,banana,cherry"
substrings = input_string.split(',')  # 按逗号分割
print(substrings)  # 输出: ['apple', 'banana', 'cherry']
```

### 3. **按固定长度分割**

如果你希望按固定长度将字符串分割成子字符串，可以使用列表推导式：

```
python复制代码# 示例输入: "abcdefghij"
input_string = input()  # 用户输入 "abcdefghij"
length = 3  # 每个子字符串的长度
substrings = [input_string[i:i+length] for i in range(0, len(input_string), length)]
print(substrings)  # 输出: ['abc', 'def', 'ghi', 'j']
```

### 4. **正则表达式分割**

如果分隔符比较复杂，可以使用 `re` 模块的 `split()` 方法：

```
python复制代码import re

# 示例输入: "apple;banana, cherry|date"
input_string = input()  # 用户输入 "apple;banana, cherry|date"
substrings = re.split(r'[;,\s|]+', input_string)  # 使用正则表达式分割
print(substrings)  # 输出: ['apple', 'banana', 'cherry', 'date']
```

### 5. **逐字符分割**

如果你想将输入字符串逐字符地分割成一个一个的字符串，可以使用 `list()` 函数：

```
python复制代码# 示例输入: "hello"
input_string = input()  # 用户输入 "hello"
substrings = list(input_string)  # 将每个字符作为一个子字符串
print(substrings)  # 输出: ['h', 'e', 'l', 'l', 'o']
```

### 总结

- **按空格或特定字符分割**: 使用 `split()` 方法。
- **按固定长度分割**: 使用列表推导式。
- **复杂分隔符分割**: 使用 `re.split()` 和正则表达式。
- **逐字符分割**: 使用 `list()` 函数。





集合

set() 集合不能出现相同元素

s = set()

s.update(input())



`s = [int(n) for n in input().split('+')]`
`s.sort()`
`print('+'.join(str(i) for i in s))`



####  将列表中的字符串连接成一个新的字符串

如果你有一个字符串列表，并且想用某个分隔符连接这些字符串，`join()` 是非常有效的方法。

```
python复制代码words = ['apple', 'banana', 'cherry']
result = ', '.join(words)
print(result)  # 输出: 'apple, banana, cherry'
```

`join()` 函数需要处理字符串类型的数据





在Python中实现大小字母互换（即将小写字母转换为大写字母，将大写字母转换为小写字母），可以使用字符串的 `swapcase()` 方法或者利用字符的 `isupper()` 和 `islower()` 方法进行手动转换。以下是几种实现方法：

### 使用 `swapcase()` 方法

`swapcase()` 方法会返回一个新字符串，其中所有的字母大小写被互换。示例如下：

```
python复制代码original_string = "Hello, World!"
swapped_string = original_string.swapcase()
print(swapped_string)  # 输出: hELLO, wORLD!
```

### 手动实现大小字母互换

如果你想手动实现这一功能，可以遍历字符串的每一个字符，检查它是否是大写或小写，然后进行相应的转换：

```
original_string = "Hello, World!"
swapped_string = ''

for char in original_string:
    if char.islower():
        swapped_string += char.upper()
    elif char.isupper():
        swapped_string += char.lower()
    else:
        swapped_string += char

print(swapped_string)  # 输出: hELLO, wORLD!
```

### 使用列表推导式

你也可以使用列表推导式来实现类似的功能：

```
python复制代码original_string = "Hello, World!"
swapped_string = ''.join([char.upper() if char.islower() else char.lower() if char.isupper() else char for char in original_string])
print(swapped_string)  # 输出: hELLO, wORLD!
```

这些方法都可以有效地实现大小字母的互换，你可以根据需要选择合适的方式。

在你的代码中，你尝试将字符串 s 的第一个字符转换为大写，但是这里有一个小错误：Python 中的字符串是不可变的，这意味着你不能直接修改字符串中的某个字符。你需要创建一个新的字符串来包含更改后的值。另外，s[0].upper() 只会返回一个大写的字符，并不会改变原始字符串 s。

正确的做法是使用字符串切片和连接操作来构建新的字符串。下面是一个修正过的版本：

s = input() if s[0].islower():    # 将第一个字符转为大写，并与剩余部分连接起来形成新字符串    

s = s[0].upper() + s[1:]

 print(s)
这段代码首先检查 s 的第一个字符是否是小写字母。如果是，它将该字符转换为大写，并将其与字符串的其余部分（从索引 1 开始到最后）连接起来，从而创建了一个新的字符串 s。最后打印出这个可能已经更新过的字符串 s。

如果你想要保持原字符串不变，并且只输出修改后的结果，你可以这样做：

python
深色版本
1s = input()
2if s[0].islower():
3    # 输出修改后的字符串而不改变原字符串
4    print(s[0].upper() + s[1:])
5else:
6    # 如果第一个字符不是小写，则直接输出原字符串
7    print(s)
这样，无论输入是什么，程序都会正确地输出第一个字符为大写的结果（如果原来就是大写或非字母字符则保持不变）。



判断相邻元素是否相同

```python
n =int(input())
m =input()
output=0
for i in range(1,n):
    if m[i] == m[i-1]:
        output+=1
print(output)
```

```
n =int(input())
m =input()
output=0
p = m[0]
for i in range(1,n):
    if m[i] == p:
        output+=1
    else:
        p = m[i]
print(output）
    print("IGNORE HIM!")
```

比较方法

min(k * l // nl, c * d, p // np） 可以选出三个中最小的一个





a.sort(reverse=True) 由大到小排序





一种选择性的print 

```
m = "0000000"in n or "1111111" in n
print("YES"if m else"NO")
```



新语法（索引并恢复到原来位置）

```python
t = int(input())
for _ in range(t):
    j, k = map(int, input().split())

    l1 = list(map(int, input().split()))
    v = [(l1[i], i) for i in range(j)]
    v.sort()

    l2 = list(map(int, input().split()))
    l2.sort()

    z = [0] * j
    for i in range(j):
        z[v[i][1]] = l2[i]

    for data in z:
        print(data, end=" ")
    print()
```





空格也算字符！！！！！！



（5//2） 上取整





import math

math.sqrt 开平方，内置函数快





避免重复计数

```
L,M = map(int,input().split())
a = [0]*(L+1)
for i in range(M):
    x,y= map(int,input().split())
    for j in range(x,y+1):
        a[j]=1
print(a.count(0))
```



s.find(xxx) 返回在列表中的第一个位置，如果没有，则返回-1

在你的代码中，使用 `s.add(range(m, n + 1))` 这行会导致 `s` 中添加的是 `range` 对象，而不是其包含的整数。你应该使用 `s.update()` 来添加范围内的所有整数。修改后的代码如下：





`from itertools import permutations` 是一个用于生成序列的所有排列的导入语句。

### 详细解释

- **`itertools`**：这是 Python 的一个内置模块，提供了许多用于操作迭代器的函数，可以高效地处理迭代器。
- **`permutations`**：这是 `itertools` 模块中的一个函数，用于生成给定可迭代对象（如列表或元组）中元素的所有可能排列。



24点循环

```python
m = int(input())
for i in range(m):
    a,b,c,d=list(map(int,input().split()))
    found = False
    for j in[a,-a]:
        for k in [b,-b]:
            for e in [c,-c]:
                for f in [d,-d]:
                    if j+k+f+e==24:
                        found=True
    print("YES" if found else"NO")
```





eval的用法：用于字符串计算



eval 函数是 Python 中的一个内置函数，它接受一个字符串作为参数，并将该字符串视为 Python 表达式来执行。eval 可以用来动态地执行 Python 代码，这在某些情况下非常有用，但同时也带来了安全风险，特别是当输入不可信时。

基本用法
eval 的基本语法如下：
result = eval("2 + 3 * 4")
print(result)  # 输出 14

x = 10
y = 5
result = eval("x + y")
print(result)  # 输出 15

global_vars = {'a': 10}
local_vars = {'b': 5}
result = eval("a + b", global_vars, local_vars)
print(result)  # 输出 15

expression = "sum([i for i in range(10)])"
result = eval(expression)
print(result)  # 输出 45





```
suma = list(map(lambda x, y: x + y, s, suma))
```

- **`map` 函数**：`map` 函数接受一个函数和一个或多个可迭代对象作为参数，并将该函数应用于每个可迭代对象的元素。它返回一个迭代器，其中包含应用函数后的结果。
- **`lambda x, y: x + y`**：这是一个匿名函数（lambda 函数），它接受两个参数 `x` 和 `y`，并返回它们的和 `x + y`。
- **`s` 和 `suma`**：这两个列表是 `map` 函数的输入。`s` 是当前读取的力向量，`suma` 是累积的力向量总和。

这行代码的作用是将 `s` 和 `suma` 中对应位置的元素相加，并将结果存储在新的 `suma` 列表中。





字典的映射：

op_dict = {"+": operator.add, "-": operator.sub}

z = {"a":5,"b":5}

for i in range(m):    a, b, c, d = [int(a) for a in input().split()]    for o in op:        if abs(op_dict[o[2]](op_dict[o[1]](op_dict[o[0]](a, b), c), d)) == 24:            output.append("YES")            break    else:        output.append("NO")



浮点数比较：

都转化为浮点数可用大于小于号比较

若想要判断是否相等

使用math.isclose 是 Python 的 math 模块中提供的一个函数，用于比较两个浮点数是否在一定的容差范围内相等。这个函数特别适用于处理浮点数的精度问题。

math.isclose 函数的参数
a 和 b：要比较的两个浮点数。
rel_tol：相对容差（relative tolerance），默认值是 1e-09。
abs_tol：绝对容差（absolute tolerance），默认值是 0.0。

```
while True:
    n = float(input())
    if math.isclose(n, 0.00, rel_tol=1e-5) :
        break
```



end = '' 可以不换行

```
 for c in s:
                print(kb[kb.index(c) - 1], end='')
```



具体来说，除了 2 和 3 以外的所有素数都可以表示为 6k±16*k*±1 的形式（其中 k*k* 是非负整数）。因此，我们只需要检查形如 6k±16*k*±1 的数。





### 代码解释

python

深色版本



```
import re
s = input()
r = re.search('h.*e.*l.*l.*o', s)
print(['YES', 'NO'][r == None])
```

1. **导入 `re` 模块**：

   python

   深色版本

   

   ```
   import re
   ```

   - 导入 Python 的正则表达式模块 `re`，以便使用正则表达式功能。

2. **读取输入**：

   python

   深色版本

   

   ```
   s = input()
   ```

   - 从标准输入读取一个字符串 `s`。

3. **使用正则表达式搜索**：

   python

   深色版本

   

   ```
   r = re.search('h.*e.*l.*l.*o', s)
   ```

   - 使用正则表达式 `'h.*e.*l.*l.*o'` 在字符串 `s` 中进行搜索。

   - 正则表达式

      

     ```
     'h.*e.*l.*l.*o'
     ```

      

     的含义是：

     - `h`：匹配字母 `h`。
     - `.*`：匹配任意数量的任意字符（包括零个字符）。
     - `e`：匹配字母 `e`。
     - `.*`：匹配任意数量的任意字符。
     - `l`：匹配字母 `l`。
     - `.*`：匹配任意数量的任意字符。
     - `l`：匹配字母 `l`。
     - `.*`：匹配任意数量的任意字符。
     - `o`：匹配字母 `o`。

   - 这个正则表达式用于检查字符串 `s` 中是否存在一个子序列，使得通过删除一些字符后可以形成 "hello"。

4. **输出结果**：

   python

   深色版本

   

   ```
   print(['YES', 'NO'][r == None])
   ```

   - 如果 `re.search` 找到了匹配项，`r` 将是一个 `re.Match` 对象，否则 `r` 将是 `None`。
   - 使用列表 `['YES', 'NO']` 和条件 `r == None` 来选择输出 "YES" 或 "NO"。
   - 如果 `r` 是 `None`，说明没有找到匹配项，输出 "NO"。
   - 如果 `r` 不是 `None`，说明找到了匹配项，输出 "YES"。

### 示例

假设输入如下：



深色版本



```
ahhellllloou
```

程序的输出将是：



深色版本



```
YES
```

假设输入如下：



深色版本



```
hlelo
```

程序的输出将是：



深色版本



```
NO
```

### 详细解释

- 正则表达式 `'h.*e.*l.*l.*o'`

  ：

  - 这个正则表达式用于查找字符串中是否存在一个子序列，使得通过删除一些字符后可以形成 "hello"。

  - 例如，在字符串 `"ahhellllloou"` 中，存在一个子序列 `h, e, l, l, o`，可以通过删除其他字符得到 "hello"，因此匹配成功。

  - 在字符串 `"hlelo"` 中，虽然有 `h, e, l, o`，但缺少第二个 `l`，因此无法通过删除字符得到 "hello"，匹配失败。

    

代码解释
Python
深色版本
print(['YES', 'NO'][r == None])
列表 ['YES', 'NO']：
这是一个包含两个字符串的列表：'YES' 和 'NO'。
条件表达式 r == None：
这个表达式检查变量 r 是否为 None。
如果 r 是 None，则 r == None 的结果是 True。
如果 r 不是 None，则 r == None 的结果是 False。
列表索引 [r == None]：
在 Python 中，布尔值 True 可以被视为整数 1，而 False 可以被视为整数 0。
因此，[r == None] 实际上是在列表 ['YES', 'NO'] 中进行索引。
如果 r == None 为 True（即 r 是 None），则索引为 1，选择列表中的第二个元素 'NO'。
如果 r == None 为 False（即 r 不是 None），则索引为 0，选择列表中的第一个元素 'YES'。





# from math import gcd 最大公约数





## 怎么建立二维列表！！

```python
e =[[0 for j in range(n+1-q)] for i in range(m+1-p)]
```

# 可以写出a【i】【j】这样的列表

   for i in range （e）：

​           C.append(list（map（int，input（）.split()))

​        这样c就为e行输入数列的列表了

# 解包行数

在 Python 中，`for i in range(e): print(*C[i])` 这一行代码是用来遍历一个列表 `C` 并打印出它的每一行。这里的关键点在于对 `print` 函数中星号（*）操作符的理解。

假设 `C` 是一个二维列表（列表的列表），其中每个元素也是一个列表，代表矩阵的一行。`e` 通常代表这个二维列表的行数。

- `range(e)` 生成一个从 0 到 e-1 的整数序列。
- `for i in range(e)` 遍历这个整数序列，每次迭代时 `i` 将依次取这些整数值。
- `C[i]` 获取 `C` 中索引为 `i` 的元素，即 `C` 的第 `i` 行。
- `*C[i]` 使用了 Python 的解包操作符 `*`，它将列表 `C[i]` 解包成独立的元素

- `print(*C[i])` 打印这些解包后的元素，并且默认情况下它们之间用空格分隔。





any(x)判断x对象是否为空对象，如果都为空、0、false，则返回false，如果不都为空、0、false，则返回true

all(x)如果all(x)参数x对象的所有元素不为0、''、False或者x为空对象，则返回True，否则返回False

```python
n = int(input())
print('NO' if all([n%i for i in (4,7,47,74,447,474,477,747,774)]) else 'YES')
```



## 取浮点数的几位小数











```
f'x1={x1:.5f} #取浮点数的小数点后后五位
```

```
x1 = format(x1, ".5f")
```

```
f'x1={"%.5f"%x1}
```



**`n.replace(n[b], "")` 语句**：`str.replace()` 方法不会修改原字符串，而是返回一个新的字符串。你需要将结果重新赋值给 `n`



## 在特定条件下寻找

`dot_index = email.find(".", at_index)` 的意思是：

- **`email.find(".", at_index)`**：在 `email` 字符串中，从位置 `at_index` 开始，寻找第一个 `.`（点）的索引位置。如果找到，返回其索引；如果找不到，返回 `-1`。
- **`at_index`**：这是 `@` 符号在 `email` 字符串中的索引位置。通过 `email.index("@")` 获得的。

### 示例：

假设邮箱是 `test@example.com`，那么：

- `at_index = email.index("@")` 会得到 `@` 在字符串中的索引位置，即 `4`。
- `email.find(".", at_index)` 会从 `@` 之后的部分开始查找第一个 `.`，在 `example.com` 中，第一个 `.` 的索引是 `11`。

因此，这个代码片段用于确保 `@` 之后确实有 `.`（并且不会紧跟在 `@` 后面）。





在 Python 中，`math` 模块提供了很多用于数学计算的常用函数。以下是一些常见的 `math` 函数及其功能：

### 1. **`math.sqrt(x)`**

- 计算 `x` 的平方根。
- 示例：`math.sqrt(16)` 返回 `4.0`

### 2. **`math.pow(x, y)`**

- 返回 `x` 的 `y` 次幂（`x^y`），类似于 `x**y`。
- 示例：`math.pow(2, 3)` 返回 `8.0`

### 3. **`math.factorial(x)`**

- 返回 `x` 的阶乘（`x!`）。
- 示例：`math.factorial(5)` 返回 `120`

### 4. **`math.log(x, base)`**

- 计算 `x` 以 `base` 为底的对数。默认是自然对数（`base = e`）。
- 示例：`math.log(8, 2)` 返回 `3.0` （2 的 3 次方等于 8）

### 5. **`math.log10(x)`**

- 返回 `x` 的以 10 为底的对数。
- 示例：`math.log10(100)` 返回 `2.0`

### 6. **`math.exp(x)`**

- 计算 `e^x`（自然数 e 的 `x` 次幂）。
- 示例：`math.exp(1)` 返回 `2.718281828459045`

### 7. **`math.sin(x)`**

- 返回 `x` 的正弦值，`x` 是以弧度为单位的角度。
- 示例：`math.sin(math.pi/2)` 返回 `1.0`

### 8. **`math.cos(x)`**

- 返回 `x` 的余弦值，`x` 是以弧度为单位的角度。
- 示例：`math.cos(0)` 返回 `1.0`

### 9. **`math.tan(x)`**

- 返回 `x` 的正切值，`x` 是以弧度为单位的角度。
- 示例：`math.tan(math.pi/4)` 返回 `1.0`

### 10. **`math.degrees(x)`**

- 将弧度转换为角度。
- 示例：`math.degrees(math.pi)` 返回 `180.0`

### 11. **`math.radians(x)`**

- 将角度转换为弧度。
- 示例：`math.radians(180)` 返回 `3.141592653589793`

### 12. **`math.ceil(x)`**

- 返回大于或等于 `x` 的最小整数（向上取整）。
- 示例：`math.ceil(3.2)` 返回 `4`

### 13. **`math.floor(x)`**

- 返回小于或等于 `x` 的最大整数（向下取整）。
- 示例：`math.floor(3.8)` 返回 `3`

### 14. **`math.fabs(x)`**

- 返回 `x` 的绝对值（总是返回浮点数）。
- 示例：`math.fabs(-5)` 返回 `5.0`

### 15. **`math.fmod(x, y)`**

- 返回 `x` 除以 `y` 的余数（浮点数）。
- 示例：`math.fmod(7, 3)` 返回 `1.0`

### 16. **`math.gcd(x, y)`**

- 返回 `x` 和 `y` 的最大公约数。
- 示例：`math.gcd(12, 8)` 返回 `4`

### 17. **`math.isqrt(x)`**

- 返回 `x` 的整数平方根。
- 示例：`math.isqrt(16)` 返回 `4`

### 18. **`math.hypot(x, y)`**

- 返回 `sqrt(x^2 + y^2)`，计算直角三角形斜边的长度。
- 示例：`math.hypot(3, 4)` 返回 `5.0`

### 19. **`math.pi`**

- `π` 的常量值，大约为 `3.141592653589793`。
- 示例：`math.pi`

### 20. **`math.e`**

- `e` 的常量值，大约为 `2.718281828459045`。
- 示例：`math.e`

### 21. **`math.isnan(x)`**

- 检查 `x` 是否为 `NaN`（Not a Number）。
- 示例：`math.isnan(float('nan'))` 返回 `True`

### 22. **`math.isinf(x)`**

- 检查 `x` 是否为无穷大。
- 示例：`math.isinf(float('inf'))` 返回 `True`



# 二进制判断2的幂次 运算符是”&“

使用位运算 `x & (x - 1) == 0` 来判断一个数是否是 2 的幂次，是一种非常高效的方法。这种方法之所以有效，是因为 2 的幂次在二进制表示中只有一个 1，其余都是 0。例如：

- 20=120=1 在二进制中是 `0001`
- 21=221=2 在二进制中是 `0010`
- 22=422=4 在二进制中是 `0100`
- 23=823=8 在二进制中是 `1000`

对于这些数，减去 1 后的结果是：

- 1−1=01−1=0 在二进制中是 `0000`
- 2−1=12−1=1 在二进制中是 `0001`
- 4−1=34−1=3 在二进制中是 `0011`
- 8−1=78−1=7 在二进制中是 `0111`

可以看到，当 `x` 是 2 的幂次时，`x - 1` 的二进制表示中的所有位都与 `x` 的二进制表示中的 1 位相对应的位置相反。因此，`x & (x - 1)` 的结果为 0。







# 元组集合比列表快！！！但是集合需要的内存多！！！





## **`set.update` 的使用错误**：`update()` 方法要求传递可迭代对象（例如列表、集合等），而不是单个元素。你传入了一个整数，因此会出现运行时错误。

## **使用 `set.add()`**：如果你要向集合中添加单个元素，应该使用 `set.add()` 而不是 `set.update()`。





## math函数做出来的是float，有时候需要转成int



## 使用m[i]与m[i-1]时一定注意

```python
for i in range(1,n):
    if m[i]>=m[i-1]:
```





**`for-else` 结构**：`else` 只有在 `for` 循环没有被 `break` 终止时才会执行。也就是说，只有当整个序列都是递增的，循环才能完成并进入 `else` 部分，输出 `"YES"`。



问题的原因在于你的 `break` 语句放在了错误的位置。由于 `break` 会立即跳出当前的循环，因此在第一次遇到 `m[i] < m[i-1]` 时，循环会终止，而不会再继续检查其它情况。与此同时，`print("NO")` 可能会被忽略，因为 `break` 会在它执行之前终止循环。

```python
n = int(input())
m = list(map(int,input().split()))
num = 1
for i in range(1,n):
    if m[i]>=m[i-1]:
        num+=1
    if m[i]<m[i-1]:
        print("NO")
    break #不能放在这里哈，print（”NO）会被忽略，后面的也不能正常运行，缩进到与print一样的地方就行了
```





# 翻转字符串

在 Python 中，翻转一个字符串有多种方法。以下是几种常见的方法：

### 方法 1：使用切片

Python 的切片功能非常强大，可以轻松地翻转字符串。

python

深色版本



```
original_string = "hello"
reversed_string = original_string[::-1]
print(reversed_string)  # 输出: olleh
```

### 方法 2：使用 `reversed()` 函数和 `join()`

`reversed()` 函数可以返回一个反向迭代器，然后你可以使用 `join()` 方法将其重新组合成一个新的字符串。

python

## 



```
original_string = "hello"
reversed_string = ''.join(reversed(original_string))
print(reversed_string)  # 输出: olleh
```

### 方法 3：使用列表的 `reverse()` 方法

你可以将字符串转换为列表，使用 `reverse()` 方法翻转列表，然后再将其转换回字符串。

python

深色版本



```
original_string = "hello"
char_list = list(original_string)
char_list.reverse()
reversed_string = ''.join(char_list)
print(reversed_string)  # 输出: olleh
```

### 方法 4：使用循环

你也可以手动编写一个循环来翻转字符串。

python

深色版本



```
original_string = "hello"
reversed_string = ''
for char in original_string:
    reversed_string = char + reversed_string
print(reversed_string)  # 输出: olleh
```

### 方法 5：使用递归

如果你喜欢递归，可以使用递归函数来翻转字符串。

python

深色版本



```
def reverse_string(s):
    if len(s) == 0:
        return s
    else:
        return reverse_string(s[1:]) + s[0]

original_string = "hello"
reversed_string = reverse_string(original_string)
print(reversed_string)  # 输出: olleh
```

### 总结

- **使用切片**：最简单且直观的方法。
- **使用 `reversed()` 和 `join()`**：灵活且易于理解。
- **使用列表的 `reverse()` 方法**：适用于需要对字符进行更多操作的情况。
- **使用循环**：手动控制翻转过程。
- **使用递归**：适合喜欢递归的开发者，但可能不如其他方法高效。



## b = bin(n)[2:]             # 转换为二进制并去掉 '0b' 前缀



## 切片语法

- ### 在 Python 中，切片是一种非常强大和灵活的功能，它允许你从序列（如字符串、列表或元组）中提取子集。切片的基本语法如下：

  python

  深色版本

  

  ```
  s[start:stop:step]
  ```

  - **`start`**：切片的起始索引（包含）。如果省略，默认为 0。
  - **`stop`**：切片的结束索引（不包含）。如果省略，默认为序列的长度。
  - **`step`**：步长，表示每隔多少个元素取一个值。如果省略，默认为 1。

  下面是一些具体的例子来说明这些参数的不同用法：

  ### 基本用法

  #### 字符串切片

  python

  深色版本

  

  ```
  s = "Hello, world!"
  print(s[0:5])  # 输出: Hello
  print(s[7:12]) # 输出: world
  ```

  #### 列表切片

  python

  深色版本

  

  ```
  l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  print(l[0:5])  # 输出: [0, 1, 2, 3, 4]
  print(l[5:10]) # 输出: [5, 6, 7, 8, 9]
  ```

  ### 省略 `start` 和 `stop`

  - 如果 `start` 省略，则默认为 0。
  - 如果 `stop` 省略，则默认为序列的长度。

  python

  深色版本

  

  ```
  s = "Hello, world!"
  print(s[:5])   # 输出: Hello
  print(s[7:])   # 输出: world!
  ```

  ### 使用负数索引

  - 负数索引表示从序列的末尾开始计数。
  - `-1` 表示最后一个元素，`-2` 表示倒数第二个元素，依此类推。

  python

  深色版本

  

  ```
  s = "Hello, world!"
  print(s[-6:-1])  # 输出: worl
  ```

  ### 使用 `step`

  - `step` 可以是正数或负数。
  - 正数 `step` 表示从前向后取元素。
  - 负数 `step` 表示从后向前取元素。

  python

  深色版本

  

  ```
  s = "Hello, world!"
  print(s[::2])    # 输出: Hlo ol!
  print(s[::3])    # 输出: Hl r
  print(s[::-1])   # 输出: !dlrow ,olleH （反向）
  print(s[::-2])   # 输出: !dwr oH （反向且每隔一个字符取一次）
  ```

  ### 切片赋值

  - 对于可变序列（如列表），你可以使用切片进行赋值。

  python

  深色版本

  

  ```
  l = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  l[1:4] = [10, 11, 12]  # 将索引 1 到 3 的元素替换为 [10, 11, 12]
  print(l)  # 输出: [0, 10, 11, 12, 4, 5, 6, 7, 8, 9]
  
  l[1:4] = []           # 删除索引 1 到 3 的元素
  print(l)  # 输出: [0, 4, 5, 6, 7, 8, 9]
  ```

  ### 总结

  - 切片是一种强大的工具，可以让你轻松地从序列中提取子集。
  - 通过组合 `start`、`stop` 和 `step` 参数，你可以实现多种不同的切片操作。
  - 对于不可变序列（如字符串），切片只能用于读取；对于可变序列（如列表），还可以用于修改。

## join只能操作字符串列表

想用它操作数字列表时可以

```python
print(" ".join(map(str,a)))
```



`print()`：在每完成一行后进行换行







### 理解因数对称性

对于任何正整数n，其因数是成对出现的。例如，12的因数有1, 2, 3, 4, 6, 和 12。这些因数可以配对如下：

- 1 和 12
- 2 和 6
- 3 和 4

每个因数对中，一个因数小于或等于√n（根号n），另一个大于或等于√n。因此，除了完全平方数以外的所有数字的因数都是成对出现的，这意味着它们会被切换偶数次状态。

### 完全平方数的情况

对于完全平方数，比如9（其因数是1, 3, 9），你会发现有一个单独的因数——它的平方根3。这个因数不会与其他因数配对，因为它自己和自己相乘得到9。因此，完全平方数的因数数量总是奇数。

### 囚犯逃脱的逻辑

- **非完全平方数**：由于非完全平方数的因数是成对出现的，所以在n轮操作后，这些牢房的状态会被切换偶数次，最终恢复到初始的锁定状态。
- **完全平方数**：完全平方数有一个单独的因数（即它的平方根），所以总的因数数量是奇数。这意味着在n轮操作后，这些牢房的状态会被切换奇数次，从而从初始的锁定状态变为解锁状态。

### 示例

假设我们有10个牢房（编号从1到10），我们来分析每个牢房被切换状态的次数：

- 牢房1：因数为1（切换1次）
- 牢房2：因数为1, 2（切换2次）
- 牢房3：因数为1, 3（切换2次）
- 牢房4：因数为1, 2, 4（切换3次）
- 牢房5：因数为1, 5（切换2次）
- 牢房6：因数为1, 2, 3, 6（切换4次）
- 牢房7：因数为1, 7（切换2次）
- 牢房8：因数为1, 2, 4, 8（切换4次）
- 牢房9：因数为1, 3, 9（切换3次）
- 牢房10：因数为1, 2, 5, 10（切换4次）

可以看到，只有编号为1、4和9的牢房被切换了奇数次状态，因此它们最终会保持解锁状态。其他牢房则会被切换偶数次状态，最终恢复到初始的锁定状态。

通过这种方式，我们可以确定哪些牢房会保持解锁状态，从而得知可以逃脱的囚犯数量。



## 如何引进无穷量

```pyhon
float("inf")
```



## float 转int

`float` 类型的数值用 `int()` 函数包裹时，Python 会执行类型转换，将浮点数转换为整数。这种转换是通过截断小数部分来实现的，也就是说，它会简单地去掉小数点后的所有数字，而不是进行四舍五入。

例如：

- `int(2.99)` 也会得到 `2`
- `int(-3.75)` 会得到 `-3`





内层的 `for i in range(j-1, n, j)`：表示狱卒在第 `j` 轮会从第 `j` 个牢房开始，并且每隔 `j` 个牢房操作一次。



## 按位异或运算

`lst[i] ^= 1` 是使用了 **按位异或运算符 (`^`)**，它表示对当前值进行翻转操作。这种写法用于在每次操作时**切换**牢房的状态，即如果牢房是锁着的 (`0`)，就将其解锁为 `1`；如果牢房是解锁的 (`1`)，就将其锁上为 `0`。

具体来说，`^` 是异或运算：

- `0 ^ 1 = 1` （锁着变为解锁）
- `1 ^ 1 = 0` （解锁变为锁上）

```python
t = int(input())
for _ in range(t):
    n = int(input())
    lst = [0]*n
    for i in range(2,n+1): #i是轮数
        for j in range(i-1,n,i):#j是索引 每隔i个数翻转一次
            lst[j]^=1
    print(lst.count(0))
```



# int和float可以直接比较

判读一个浮点数是不是整数，将其int一下，再比较两个数是否相等，判断开平方出来的数是不是整数就可以这么干



## **埃拉托斯特尼筛法**  找质数

快速寻找一个范围内所有质数

从小到大遍历所有数，遇到一个质数后，就将其所有倍数标记为非质数。

最后，未被标记为非质数的所有数就是质数。

```python
# 使用埃拉托斯特尼筛法来计算所有小于等于 10^6 的质数
def sieve(limit):
    is_prime = [True] * (limit + 1)
    is_prime[0] = is_prime[1] = False  # 0 和 1 不是质数
    for i in range(2, int(math.sqrt(limit)) + 1):
        if is_prime[i]:
            for j in range(i * i, limit + 1, i):
                is_prime[j] = False
    return is_prime

# 创建一个用于判断某数是否为质数的布尔列表
limit = 10**6
is_prime_list = sieve(limit)
```

得像访问列表一样访问 is_prime_list[]要这样

## 它不是一个字符串或者整数列表，是一个布尔列表，只能通过访问is_prime_list[]来判断是不是质数，再说一次，它不是一个从0到limit中所有质数的列表



这样也可以而且看起来比简单

```python
n = 1000000
a = [1] * n
s = set() 

#directly add the square of prime into a set, then check if num_input is in set.
for i in range(2,n):
    if a[i]:
        s.add(i*i)
        for j in range(i*i,n,i):
            a[j] = 0

input()
for x in map(int,input().split()):
    print(["NO","YES"][x in s])
```



## 更快的欧拉筛法

```python
def oula(r):
    # 全部初始化为0
    prime = [0 for i in range(r + 1)]
    # 存放素数
    common = []

    for i in range(2, r + 1):
        if prime[i] == 0:
            common.append(i)

        for j in common:
            if i * j > r:
                break
            prime[i * j] = 1
            # 将重复筛选剔除
            if i % j == 0:
                break

    return common


prime = oula(20000)
print(prime)
```



## reverse=True：

reverse 参数控制排序的方向。如果 reverse=True，则列表将按降序排序；如果 reverse=False 或省略该参数，则按升序排序。



## dp(随便一个名称）=[0]的意思

`dp = [0]` 是一个列表（List），它是 Python 中用来存储多个元素的一种数据结构。在这里，`dp` 是一个一维列表，其初始值为 `[0]`，表示该列表的第一个元素是 0。

### 具体解释

- **列表（List）**：在 Python 中，列表是一种可变的序列，可以包含任意类型的元素。列表的元素可以通过索引访问。
- **初始化为 `[0]`**：在此代码中，`dp` 列表被初始化为一个包含单个元素 0 的列表。这个 0 用来表示从字符串开头到第一个字符的相邻相等对的数量（显然为 0）。

### 为什么用列表？

在这个问题中，我们需要记录每个位置之前的相邻相等字符对的数量。使用列表 `dp` 可以方便地存储这些数量，且可以通过索引快速访问。

### 示例

例如，如果字符串是 `s = "..#..#"`，经过处理后，`dp` 可能变成：

- `dp = [0, 1, 1, 1, 2, 2]`

这里：

- `dp[0]` 表示到位置 0 的相邻相等对数量（0 对）。
- `dp[1]` 表示到位置 1 的相邻相等对数量（1 对）。
- `dp[2]` 表示到位置 2 的相邻相等对数量（1 对）。
- 以此类推。



`dp = [0]` 和 `dp = []` 在这里的意义有所不同，尤其是在处理后续查询时。

### 使用 `dp = [0]` 的原因

1. **初始化**：`dp` 数组的第一个元素 `dp[0]` 用来表示从字符串开头到位置 0（也就是没有字符）的相邻相等对的数量。显然，这个数量是 0，因此我们初始化为 `[0]`。
2. **索引对齐**：在后续的处理过程中，`dp[i]` 实际上表示从字符串开始到第 `i` 个字符（1-based 索引）的相邻相等对的数量。
   - 当你查询 dp[right−1]−dp[left−1]dp[right-1] - dp[left-1]dp[right−1]−dp[left−1] 时，`left` 和 `right` 是 1-based 索引，所以 `dp[left-1]` 和 `dp[right-1]` 能够正确地获取到相应位置的计数。

### 如果使用 `dp = []` 会怎样

如果你使用 `dp = []`，在之后的计算中需要特别处理 `dp[0]` 的情况。因为在 Python 中，`dp[0]` 会导致索引错误（越界），特别是在你试图通过 `dp[left-1]` 来访问元素时。

### 举例说明

假设字符串 `s = "..#..#"`，我们想处理的 `dp` 数组会是这样的：

- 使用 

  ```
  dp = [0]
  ```

  ：

  - `dp[1]` 表示前 1 个字符的相等对数量。
  - `dp[2]` 表示前 2 个字符的相等对数量。

这样，索引会从 0 开始，避免了后续的越界问题。

- 如果使用 `dp = []`，你将需要手动管理这些索引，并且在访问 `dp[left-1]` 时会出错。

## **deque**

```
from collections import deque
```

`deque` 是 Python 的双端队列，支持从两端快速插入和删除操作。

   =deque

以约瑟夫问题为例，看deque的用处

from collections import deque

# 先使用pop从列表中取出，如果不符合要求再append回列表，相当于构成了一个圈


```python
def hot_potato(name_list, num):
    queue = deque()
    for name in name_list:
        queue.append(name)


while len(queue) > 1:
    for i in range(num):
        queue.append(queue.popleft()) # O(1)
    queue.popleft()
return queue.popleft()

while True:
    n, m = map(int, input().split())
    if {n,m} == {0}:
        break
    monkey = [i for i in range(1, n+1)]
    print(hot_potato(monkey, m-1))
```



## 以列表中每个元组的第二个元素为准进行排序

**key=lambda x: x[1]**：指定排序的关键字，这里用的是元组的第二个元素 b（即 `x[1]`）,以此类推

sorted_hotels = sorted(hotels, key=lambda x: x[1])





## 用嵌套循环就可以实现以一个数字为基准进行全比较！

```python
for i in range(N):
    for j in range(i+1,N):
```



## key = lambda x :(x[0],x[1])，key = lambda x: len(x)

- `key=lambda x: (x[0], x[1])` 指定了排序的关键字。这里的 `lambda` 函数返回一个包含两个元素的元组 `(x[0], x[1])`。



- **主要关键字**：`x[0]`，即每个元素的第一个元素。
- **次要关键字**：`x[1]`，即每个元素的第二个元素。

## pop后直接跟索引

.pop(0)



## 不能边遍历边删除，铁错哈



## 一对一匹配可以用双指针法，不用遍历，节省时间，（当然也可以用嵌套循环）简单的配对可以见weather restore

```python
a.sort()
b.sort()
num = 0
i = 0
j = 0
while i<n and j<m:
    if abs(a[i]-b[j])<=1:
        num+=1
        i+=1;j+=1
    elif a[i]<b[j]:
        i+=1
    else:
        j+=1
print(num)
```



### 你的代码遇到超时问题，主要原因是每次处理查询时都对列表进行 `sorted()` 排序操作，而排序的时间复杂度是 `O(n log n)`，这会导致在多个查询时效率变低，尤其是在 `m` 比较大的时候。

### 直接使用 `sum()` 函数在每次查询时计算区间和会导致效率低下



## 前缀和

**前缀和** 是一种快速查询区间和的方法。它的思想是预处理一个数组 `prefix_sum`，其中每个位置 `prefix_sum[i]` 存放的是原数组前 `i` 个元素的和。这样，当我们想要查询数组某个区间 `[b, c]` 的和时，只需要通过简单的减法就可以得到结果。怎么不算dp



## dp的关键是储存计算结果，最后用加减得到答案

dp = [-1]*21

## 缓存计算结果的函数

### from functools import lru_cache 

```python
from functools import lru_cache 

@lru_cache(maxsize = 128) 
def f(n):
    if n <= 2:
        return 1
    else:
        return f(n-1)+f(n-2)


n = int(input())
list_1 = []
for i in range(n):
    num = int(input())
    list_1.append(f(num))
for i in list_1:
    print(i)
```

`maxsize` 参数指定了缓存的最大条目数。当缓存达到最大容量时，最近最少使用的条目会被移除，以腾出空间给新的条目。

@lru_cache(maxsize = 128) 过后一定要定义han'shu



## 模运算不变化

在递推公式中直接取模是基于模运算的性质，特别是模运算的分配律。这些性质确保了我们在每一步计算中取模的结果与最终结果取模是一致的。具体来说，模运算有以下重要的性质：

1. **加法分配律**：

   (a+b)mod  m=((amod  m)+(bmod  m))mod  m(*a*+*b*)mod*m*=((*a*mod*m*)+(*b*mod*m*))mod*m*

2. **乘法分配律**：

   (a×b)mod  m=((amod  m)×(bmod  m))mod  m(*a*×*b*)mod*m*=((*a*mod*m*)×(*b*mod*m*))mod*m*

   算完后取模和运算时取模是一样的

## Brute force 穷举



## 哈希表 `complement_map` （字典) 可以避免双重循环

complement_map[] = 

[]里的值不是索引，是键        括号里的值也存在于字典之中

等号后的值是值

例如：

```python
n = int(input())
for _ in range(n):
    s = int(input())
    A = int(input())
    a = list(map(int,input().split()))
    B = int(input())
    b = list(map(int,input().split()))
    x = {}
    for i in a:
       if s-i in x:
           x[s-i] += 1
       else:
           x[s-i]=1
    num = 0
    for j in b:
        if j in x:
            num+=x[j]
    print(num)
```



## 储存元组

moves = [tuple(map(int, input().split())) for _ in range(k)]

python

深色版本



```python
moves = [tuple(map(int, input().split())) for _ in range(k)]
```

1. **`for _ in range(k):`**:
   - 这是一个循环，它会执行 `k` 次。`k` 是之前从输入中读取的整数，表示 Pasha 将要进行的操作次数。
   - `_` 是一个常用的占位符变量名，表示我们不关心每次循环的具体值，只是需要循环 `k` 次。
2. **`input().split()`**:
   - `input()` 读取一行输入，例如 `"1 2"`。
   - `.split()` 将这一行输入按空格分割成一个字符串列表，例如 `["1", "2"]`。
3. **`map(int, ...)`**:
   - `map(int, ["1", "2"])` 将列表中的每个字符串转换为整数，生成一个迭代器 `[1, 2]`。
4. **`tuple(...)`**:
   - `tuple([1, 2])` 将这个迭代器转换为一个元组 `(1, 2)`。
5. **列表推导式**:
   - `[...]` 是一个列表推导式，它将每次循环的结果（即每次操作的元组）收集到一个列表 `moves` 中。

## 在处理边界问题时，可以使用保护圈，即在列表外多加一层，具体见Pasha and Pixels

```python
mx = [(m+2)*[0] for i in range(n+2)]
mx = [[0]* (m+2) for j in range(n+2)]
```



## 检测是否都为True的if语法

```python
if mx[i-1][j] and mx[i-1][j+1] and mx[i][j+1]:
    return True
```

其中几个要素如果都为True 则返回True

注意 1 = True

几个因素的值都为1意思就是都为True



## 怎么单单调出字典的值里

错误示范

```
if ac in g:
    g[ac]+=a
    t.append((g[ac]))
```



正确

```python
if ac in g:       
    for (b, c, d) in g[ac]: 
        t.append((a,b,c,d))
```



## 从某个工具库中调出全部

 `from collections import *`



## collections库中Counter函数的用处

```python
from collections import *
input()
print(max(Counter(input().split()).values()))
```

Counter 返回的是字典（输入的量是键 ， 出现的次数是值

```python
from collections import *
```

- **解释**：这里使用了 `from collections import *`，表示从 Python 的 `collections` 模块导入所有工具。这包括 `Counter`, `defaultdict`, `deque` 等非常有用的数据结构。在这个代码中，主要使用的是 `Counter`。

```python
input()
```

- **解释**：这行代码是用来接收第一行输入的，也就是盒子的数量 `n`。但这个输入值没有被存储，实际上这行代码可以省略，因为后面的逻辑不需要直接使用 `n`。

```python
print(max(Counter(input().split()).values()))
```

- 解释

  ：

  1. **`input().split()`**：
     - `input()` 用来接收第二行输入，它是一个包含所有盒子大小的字符串。
     - `.split()` 将这个输入字符串按空格分割成一个列表，每个元素是盒子的大小，格式为字符串类型。
  2. **`Counter(input().split())`**：
     - `Counter` 是 `collections` 模块中的一个工具，它用来统计列表中每个元素出现的次数。`input().split()` 会产生一个盒子大小的列表，`Counter` 会统计每个盒子大小出现的频率。
     - 例如，如果输入是 `4 3 3 2 1`，则 `Counter` 结果是 `Counter({'3': 2, '4': 1, '2': 1, '1': 1})`，表示大小为 `3` 的盒子出现了 2 次，其它盒子各出现 1 次。
  3. **`.values()`**：
     - `Counter` 返回的是一个字典，它的键是盒子大小，值是对应的出现次数。`.values()` 会返回所有出现次数的值，形成一个列表。
     - 例如，上面的例子中，`.values()` 返回 `[2, 1, 1, 1]`，表示各个盒子大小的出现次数。
  4. **`max()`**：
     - `max()` 函数会从 `.values()` 返回的列表中，找出最大的值。这个最大值就是某个盒子大小的最大出现次数，也就是可见盒子中最多的盒子数量。
     - 例如，在 `[2, 1, 1, 1]` 中，最大值是 `2`，表示有 2 个相同大小的盒子，这将是最小可能的可见盒子数量。



## 列表可以使用insert insert(index,object)



## Stack

栈（Stack）是一种只能在一端进行插入或删除的线性表，在主程设计中经常用来处理具有“后进先出”（LIFO, Last In First Out）特性的数据结构。栈的基本操作包括：

1. **Push**：将一个元素添加到栈顶。
2. **Pop**：移除并返回栈顶的元素。
3. **Peek/Top**：返回栈顶的元素但不移除它。
4. **IsEmpty**：检查栈是否为空。
5. **Size**：返回栈中的元素数量。

### 栈的应用

- **函数调用栈**：在程序执行过程中，每调用一个函数时，该函数的局部变量、参数等信息会被压入栈中。当函数返回时，这些信息会被弹出栈。
- **表达式求值和转换**：例如，将中缀表达式转换为后缀表达式（逆波兰表示法），以及计算后缀表达式的值。
- **括号匹配**：检查括号是否正确配对。
- **浏览器的前进/后退功能**：使用两个栈来实现网页浏览历史的前进和后退。
- **撤销/重做功能**：在文本编辑器或绘图软件中，可以使用栈来实现撤销和重做操作。

### 在当前问题中的应用

## 十进制转K进制

不停的除以K，所得余数为倒数第一位，倒数第二位   直到第一位的数字

```
n,K = map(int,input().split())
num = 0
output = []
g = {10:"A",11:"B",12:"C",13:"D",14:"E",15:"F"}
while n>0:
    numm = n%K
    n=n//K

    if numm in g:
        output.append(g[numm])
    else:
        output.append(numm)
output.reverse()
print(''.join(map(str,output)))
```



## ord与chr的互相编译，实现字母和数字的转换（分大小写）

### `ord()` 函数

`ord()` 函数接受一个单字符参数，并返回其对应的 ASCII 编码值。ASCII 编码是一种用整数编码字符的标准，其中每个字符都有一个唯一的整数值。例如，`ord('A')` 返回 65，`ord('Z')` 返回 90。

### `chr()` 函数

`chr()` 函数接受一个整数参数，并返回该整数对应的字符。例如，`chr(65)` 返回 'A'，`chr(90)` 返回 'Z'。

- 大写字母从 `A` 到 `Z` 的编码值范围是 65 到 90。
- 小写字母从 `a` 到 `z` 的编码值范围是 97 到 122。



## 负数可以进行取模

负数取模的结果是一个**非负数**，并且遵循这样的规则：**结果的符号与除数相同**。

比如说 -5%26=21

在 Python 中，负数取模的结果是一个**非负数**，并且遵循这样的规则：**结果的符号与除数相同**。

例如，对于表达式 `a % b`，如果 `a` 是负数，而 `b` 是正数，则 Python 会返回一个非负数结果，其计算过程如下：

### 计算规则：

```
css


复制代码
a % b = a - b * floor(a / b)
```

这里 `floor(a / b)` 是 `a / b` 的**向下取整**（即不超过商的最大整数），这保证了结果始终在 `[0, b)` 范围内。

### 示例：

1. **正数取模：**

   ```
   python
   
   
   复制代码
   5 % 3  # 结果是 2
   ```

   解释：`5 / 3 = 1.666...`，向下取整 `1`，所以 `5 - 3 * 1 = 2`。

2. **负数取模：**

   ```
   python
   
   
   复制代码
   -5 % 3  # 结果是 1
   ```

   解释：`-5 / 3 = -1.666...`，向下取整 `-2`，所以 `-5 - 3 * (-2) = 1`。

3. **负数和负数取模：**

   ```
   python
   
   
   复制代码
   -5 % -3  # 结果是 -2
   ```

   解释：`-5 / -3 = 1.666...`，向下取整 `1`，所以 `-5 - (-3 * 1) = -2`。

### 总结：

- **如果除数是正数**，无论被除数是正还是负，模运算结果总是**非负数**。
- **如果除数是负数**，模运算结果则是**负数**。

### 实际应用：

在加密解密中，使用取模操作确保字母表的循环（即结果保持在 `[0, 25]` 范围内）。



## 判断输入是否是整数用.isdigit()

```python
input_data = input().strip()

if input_data.isdigit():
    num = int(input_data())
    
```

## if __name__=="__main__"这一部分代码的意思是：

```python
if __name__ == "__main__":#两个下划线
    main()
```

1. **如果这个文件是直接运行的**（而不是作为模块导入），那么 `__name__` 的值就是 `"__main__"`。
2. **此时就会执行 `main()` 函数**，也就是程序的主入口，开始执行主要的逻辑。



## 列表不能用update

如果你想在 `列表` 中添加、修改、删除元素，应该使用列表的方法，如：

- `append()`：在列表末尾添加元素

- ## `extend()`：扩展列表，添加多个（可迭代）元素

- `insert()`：在指定位置插入元素

- `remove()`：移除指定的元素

- `pop()`：删除指定位置的元素（默认删除最后一个）

- `sort()`：对列表进行排序

- `reverse()`：倒转列表顺序

## 如何打印从p到n，再从1到p-1的列表

```python
l=list(range(p,n+1)+range(1,p))
```



## .pop()默认删除末尾的一个数，.pop(0)删除第一个数



## 使用元组要小心

## 你说得对，你的代码确实通过 `b.sort(key=lambda x: x[1])` 将字符串按长度从小到大排序了，并且你只遍历了最短字符串的长度：

```
python


复制代码
for i in range(b[0][1]):  # 遍历最短字符串的长度
```

**但是，问题依然可能出现在排序后的其他字符串上。**尽管你确保了最短字符串在第一个位置，仍然有可能 `b[j][i]` 越界，原因在于你排序后的数据结构 `b` 并不是一个单纯的字符串列表，而是一个包含 `(字符串, 字符串长度)` 的 **元组列表**。

在你的代码中，`b[j][i]` 试图访问的是元组的第 `i` 个元素，而元组中只有两个元素（字符串和长度），所以会引发索引越界。

### 解决办法：

在你的代码中，当你访问 `b[j][i]` 时，实际上应该访问元组中的第一个元素，也就是 `b[j][0]`（字符串）。改成 `b[j][0][i]` 来访问字符串的第 `i` 个字符。

你可以将这段代码修正如下：

```
python复制代码for i in range(b[0][1]):  # 遍历最短字符串的长度
    for j in range(1, n):
        if b[j][0][i] == b[j-1][0][i]:  # 访问字符串中的字符
            num += 1
        else:
            break
```

### 关键修改：

- `b[j][0][i]`：这里我们明确指定访问元组中的第一个元素，也就是实际的字符串，然后再用 `i` 来访问该字符串的字符。





## 输出空行

即为print（）



## 【：：n】中的n是步长，【：n】是从一到n





**`import sys`**:

- 导入 Python 的 `sys` 模块，`sys` 模块提供了一些与 Python 解释器交互的功能，比如访问标准输入、输出和命令行参数等。

## **`input = sys.stdin.read`**:

- 这里把标准输入的 `sys.stdin.read()` 赋值给了 `input`。这样做之后，`input()` 不再是 Python 默认的 `input()` 函数，而是 `sys.stdin.read()`，它会一次性读取所有输入，直到输入流结束（通常是通过用户键入 Ctrl+D 或 Ctrl+Z）。
- `sys.stdin.read()` 读取整个输入的所有内容，而不像 `input()` 那样只读取一行。适合读取多行输入，尤其是在处理文件或大段数据时。

**`data = input().split()`**:

- `input()` 现在其实是 `sys.stdin.read()`，所以这行代码会从标准输入中读取所有内容。
- `.split()` 会按默认的空格或换行符分割输入，将其分成一个个字符串，返回一个列表。每个字符串原本是由空格、换行符或其他分隔符分割出来的一部分。



### 为什么使用 `n+1`？

1. **基于 1 的索引**：
   - 在许多实际问题中，特别是涉及人的编号或节点编号时，通常是从 1 开始编号的（即 1, 2, 3, ...）。如果直接使用 `n` 作为数组的长度，那么索引将从 0 开始，这会导致不一致。
   - 通过使用 `n+1`，可以方便地用 1 到 n 之间的整数来表示人或节点的编号，而不需要进行额外的索引转换。
2. **简化逻辑**：
   - 如果使用 `n` 作为数组的长度，那么在处理输入数据时，每次都需要将输入的编号减 1 才能正确地访问数组。例如，如果输入的编号是 1 和 2，你需要访问 `exists[0][1]` 和 `exists[1][0]`。
   - 使用 `n+1` 可以直接使用输入的编号，而不需要进行任何转换。例如，如果输入的编号是 1 和 2，你可以直接访问 `exists[1][2]` 和 `exists[2][1]`。
3. 0不用管，直接管1到n+1就行

## 对于看不出数字关系的，直接遍历直接计算机思维进行枚举



## 优化

1.用内置函数（去查一下）



## 有周期就取模，有周期就取模，绝对位置不重要，重要的是相对位置！！



## 仅仅翻转列表，不要sort（reverse=True），不要c=c.reverse()(会返回None)，不要把reverse写成reserve

## 翻转是c.reverse()!!!





## 方法.zfill 只用于字符串！！！！不用于列表！！！！填0

```python
 m = m.zfill(len(n))
```

使用 `zfill` 方法来确保两个字符串具有相同的长度。`zfill` 方法会在字符串前面填充 `0`，直到达到指定的长度。

## 方法.lstrip去除字符串左侧特定字符（比如0

`.lstrip('0')` 是 Python 字符串方法 `lstrip()` 的一种使用方式，用于去除字符串左侧（开头）的特定字符。在这个例子中，它用于去除字符串开头的零（`'0'`）。



## 方法range()

- ```
  range(len(m) - 1, -1, -1)
  ```

  

  ## range()函数的一个用法，它接受三个参数：起始值、结束值（不包含）和步长。

  - `len(m) - 1` 是起始值，表示从列表 `m` 的最后一个索引开始。
  - `-1` 是结束值，但不包含在内。这意味着循环会一直执行到 `0`。
  - `-1` 是步长，表示每次迭代时索引减少 1。

## 关于插入

```
n.insert(0, '0' * a)
```

在0的位置插入000000这种字符，而不是从0开始，往1，2，3等位置加0，这个时候我们可以用.zfill()

## Greedy 一般是先要sort







## a,b,c,d=map(input().count,('1','2','3','4'))

### 这行代码的核心作用是统计每组学生人数为1、2、3和4的分别有多少组。









## functools.cmp_to_key 自定义函数的比较

在 Python 的 `sorted()` 函数中，使用自定义比较函数来决定元素的排列顺序。当我们通过比较函数比较两个元素时：

- **如果返回正数**，Python 会认为**第一个元素应该排在第二个元素之后**（即 `y` 在 `x` 前面）。
- **如果返回负数**，则相反，**第一个元素应该排在第二个元素之前**（即 `x` 在 `y` 前面）
- 
- ```python
  import functools
  def compare(x,y):
      if x+y>y+x:
          return -1
      elif x+y<y+x:
          return 1
      else:
          return 0
  n=int(input())
  c=list(map(str,input().split()))
  c_max = sorted(c,key = functools.cmp_to_key(compare))
  c_min= sorted(c,key = functools.cmp_to_key(lambda x,y:compare(y,x)))
  print(''.join(map(str,c_max)),end = " ")
  print(''.join(map(str,c_min))
  ```





## 当x，y为str时，x+y可以直接计算，为x，y的拼接，y+x则为y与x的拼接



## 要想sort集合，要不转换成列表再sort（），要么定义新集合=sorted（原集合）





## 怎么根据分割点分割列表！

```python
# 将集合 f 转换为有序列表
sorted_f = sorted(f)#f是分割点的集合

# 根据分割点将列表 c 分割成 m 个子列表
sublists = []
start = 0
for end in sorted_f:
    sublists.append(c[start:end])
    start = end
```



## bisect 的用法

### 用法场景

1. **查找插入位置：** `bisect` 可以用来在有序列表中插入元素，而不打乱顺序。

```
python复制代码import bisect

a = [1, 2, 4, 8]
bisect.insort(a, 3)
print(a)  # 输出: [1, 2, 3, 4, 8]
```

1. **查找范围：** 你可以使用 `bisect_left` 和 `bisect_right` 来找到在某个区间内的元素。

```python
python复制代码a = [1, 2, 4, 4, 8, 10]
# 找到范围 (2, 8) 内的元素
left = bisect.bisect_right(a, 2)  # 找到第一个大于 2 的索引
right = bisect.bisect_left(a, 8)  # 找到第一个大于等于 8 的索引
print(a[left:right])  # 输出: [4, 4]
```

### 总结

- `bisect_left`：返回可以插入 `x` 的最左侧位置。
- `bisect_right`：返回可以插入 `x` 的最右侧位置（即大于 `x` 的第一个位置）。
- `insort`：在保持有序的情况下插入元素。

`bisect` 非常适合处理有序列表的二分查找或插入操作，能够让代码更简洁高效。

## 元组列表直接访问其中元素即可，不需要双重访问

l=[(a,b),(c,d)]

访问直接 for a,b in l:  就可以了





对于你的问题，我们可以通过模运算（取模）的性质来解释为什么“去掉一头就够了”的情况成立。

### 1. **模运算性质**

模运算的基本性质是：
若两个数 aaa 和 bbb 满足 a≡b(modx)a \equiv b \pmod{x}a≡b(modx)，那么 (a+b)≡(a(modx))+(b(modx))(modx)(a + b) \equiv (a \pmod{x}) + (b \pmod{x}) \pmod{x}(a+b)≡(a(modx))+(b(modx))(modx)。

- 如果一个数组的和是 xxx 的倍数，那么该数组的模 xxx 等于 0。即 sum(a)≡0(modx)\text{sum}(a) \equiv 0 \pmod{x}sum(a)≡0(modx)。
- 当你从数组中去掉一段，比如头或者尾的元素，它们的和会对整个数组的和产生影响。去掉这些数后，剩下的和会发生改变。

### 2. **去掉一头的解释**

假设整个数组的和 sum(a)≡0(modx)\text{sum}(a) \equiv 0 \pmod{x}sum(a)≡0(modx)，即数组的和是 xxx 的倍数。现在我们设数组开头的一段和是 AAA，尾部的一段和是 BBB，我们想要让数组的和不再是 xxx 的倍数。

那么根据你的设定，去掉一头（不是 xxx 倍数的那头）就够了。这个过程可以通过模运算来解释。

- **情况 1：去掉头部 AAA**
  如果头部 AAA 的和 **不是** xxx 的倍数，即 A≢0(modx)A \not\equiv 0 \pmod{x}A≡0(modx)，那么去掉这一部分时，剩下的数组的和将是
  sum(a)−A≡0−A≡−A(modx)\text{sum}(a) - A \equiv 0 - A \equiv -A \pmod{x}sum(a)−A≡0−A≡−A(modx)。
  因为 A≢0(modx)A \not\equiv 0 \pmod{x}A≡0(modx)，所以 −A≢0(modx)-A \not\equiv 0 \pmod{x}−A≡0(modx)。
  这意味着去掉头部后，新的数组和不再是 xxx 的倍数了。
- **情况 2：去掉尾部 BBB**
  如果尾部 BBB 的和 **不是** xxx 的倍数，即 B≢0(modx)B \not\equiv 0 \pmod{x}B≡0(modx)，类似地，去掉这一部分时，剩下的数组的和将是
  sum(a)−B≡0−B≡−B(modx)\text{sum}(a) - B \equiv 0 - B \equiv -B \pmod{x}sum(a)−B≡0−B≡−B(modx)。
  因为 B≢0(modx)B \not\equiv 0 \pmod{x}B≡0(modx)，所以 −B≢0(modx)-B \not\equiv 0 \pmod{x}−B≡0(modx)。
  这意味着去掉尾部后，新的数组和也不再是 xxx 的倍数了。

### 3. **为什么去掉一头就够了？**

如果你知道头部或尾部的一段和不是 xxx 的倍数（比如 A≢0(modx)A \not\equiv 0 \pmod{x}A≡0(modx) 或 B≢0(modx)B \not\equiv 0 \pmod{x}B≡0(modx)），你只需要去掉这一段，整个数组的和就不再是 xxx 的倍数了。

因此，你无需去掉头和尾两段中的某一部分，只要去掉不满足 xxx 倍数的那一段即可。这是因为一旦去掉某一部分后，新的子数组和就已经不能被 xxx 整除了。

### 4. **总结**

通过模运算，我们可以理解：

- 当数组的和是 xxx 的倍数时，我们需要通过删除某一段来打破这个整除性。
- 如果头或尾的一段和不是 xxx 的倍数，那么去掉这一段后，剩下的和就不会再被 xxx 整除了，因此只需去掉这一段即可。

## .strip()移除多余空格！！！



## 解包操作符

print(*ans) 可以把ans列表中的东西按空格分开打印





## 前缀和！！！

在 Python 或编程中，**前缀和**（Prefix Sum）是一种用于快速计算一组连续数之和的技巧。前缀和的核心思想是通过预处理数组，构建一个新的数组，使得可以在常数时间内（O(1)）求出任意区间的和。

### 举个例子：

假设有一个数组 `arr = [3, 1, 4, 1, 5]`，现在如果需要频繁查询某个区间的和，比如求 `arr[1]` 到 `arr[3]` 之间元素的和（即 `1 + 4 + 1 = 6`），直接计算会花费 `O(n)` 的时间。而通过前缀和数组，可以将求和操作简化为常数时间 `O(1)`。

### 前缀和数组的定义

定义一个前缀和数组 `prefix`，使得 `prefix[i]` 表示数组 `arr` 前 `i` 个元素的和，即：

prefix[i]=arr[0]+arr[1]+⋯+arr[i−1]\text{prefix}[i] = \text{arr}[0] + \text{arr}[1] + \dots + \text{arr}[i-1]prefix[i]=arr[0]+arr[1]+⋯+arr[i−1]

那么数组 `arr` 的前缀和数组 `prefix` 为：

- `prefix[0] = 0` （方便计算，从索引 `0` 开始）
- `prefix[1] = arr[0]`
- `prefix[2] = arr[0] + arr[1]`
- `...`
- `prefix[i] = arr[0] + arr[1] + ... + arr[i-1]`

对于区间 `[l, r]` 的和，可以通过前缀和数组快速得到：

sum(arr[l:r+1])=prefix[r+1]−prefix[l]\text{sum}(arr[l:r+1]) = \text{prefix}[r+1] - \text{prefix}[l]sum(arr[l:r+1])=prefix[r+1]−prefix[l]

### 如何计算前缀和数组

代码如下：

```python
python复制代码arr = [3, 1, 4, 1, 5]
n = len(arr)

# 初始化前缀和数组
prefix = [0] * (n + 1)  # 多加一个空间，prefix[0] = 0

# 计算前缀和数组
for i in range(1, n + 1):
    prefix[i] = prefix[i - 1] + arr[i - 1]

# 查看前缀和数组
print(prefix)  # 输出: [0, 3, 4, 8, 9, 14]
```



## enumerate函数，能保存原始索引

`enumerate` 的作用是**枚举**或**列举**一个可迭代对象（如列表、字符串、元组等）的元素，并在返回时为每个元素提供一个索引（即位置编号）



### 索引放在元组的第一个

```python
n = int(input())
t = [(i, int(j)) for i, j in enumerate(input().split(), 1)]#表示从1开始
tt = t.copy()
tt.sort(key=lambda x: x[1])

ans = []
for i in tt:
    ans.append(i[0])

print(*ans)

dp = [0] * n
dp[0] = 0
for i in range(1, n):
    dp[i] = dp[i - 1] + tt[i - 1][1]

print('{:.2f}'.format(sum(dp) / n))
```





一般有开始结束的，拿第二个数值排，一般就能顺利地进行，雷达安装，进程检测





优先队列，单调栈，队列，，，等我期中过后好好学哈嗷嗷



## isqrt函数 开方后取整



## 解决一次输入数据过多

import sys

input=sys.stdin.read

data = input().split()



## 递归

函数调用了自己



## 切片

- `data[idx:idx + 2]` 是一个切片操作，它从索引 `idx` 开始，到 `idx + 2` 之前的元素（不包括 `idx + 2`）。



## return

return过后没有结束没有结束没有结束

函数还可以运行啊





weights[i]<B时，这里表示从B一直遍历到weights[i]

```python
for j in range(B,weights[i]-1,-1):
```





## 0-1背包问题（dp）

#### 压缩矩阵滚动数组法

```python
N,B = map(int,input().split())
prices=list(map(int,input().split()))
weights=list(map(int,input().split()))
dp = [0] * (B+1)
for i in range(N):
    for j in range(B,weights[i]-1,-1):
        dp[j]=max(dp[j],dp[j-weights[i]]+prices[i])
print(max(dp))
```

#### 一般矩阵法

```python
N,B = map(int,input().split())
price=[0]+[int(x) for x in input().split()]
weight =[0]+[int(x) for x in input().split()]
bag = [[0]*(B+1) for i in range(N+1)]
for i in range(1,N+1):
    for j in range(1,B+1):
        if weight[i]<=j:
            bag[i][j]=max(bag[i-1][j],bag[i-1][j-weight[i]]+price[i])
        else:
            bag[i][j]=bag[i-1][j]
print(dp[-1])
```





## 浅拷贝，由于引用时常常一个跟着一个变化，所以需要拷贝

使用 `path[:]` 是为了避免引用问题，确保 `result` 列表中存储的是独立的列表副本，而不是对 `path` 的引用。这在递归过程中非常重要，因为 `path` 会在递归调用中不断变化，如果我们直接将 `path` 添加到 `result` 中，那么 `result` 中的所有排列都会指向同一个列表对象，导致最终结果不正确。

### 详细解释

#### 引用问题

在 Python 中，列表是可变对象。当你将一个列表添加到另一个列表中时，实际上是将对原列表的引用添加到了新列表中。这意味着，如果原列表发生变化，所有引用该列表的地方都会看到这些变化。

例如：

python

深色版本



```
a = [1, 2, 3]
b = [a]
print(b)  # 输出: [[1, 2, 3]]

a.append(4)
print(b)  # 输出: [[1, 2, 3, 4]]
```

在这个例子中，`b` 列表中存储的是对 `a` 的引用，因此当 `a` 发生变化时，`b` 也跟着变化。

#### 使用 `path[:]` 创建副本

为了避免这种引用问题，我们可以使用 `path[:]` 来创建 `path` 的一个浅拷贝。这样，即使 `path` 在后续的递归调用中发生变化，`result` 中存储的仍然是原始的排列。

例如：

python

深色版本



```
a = [1, 2, 3]
b = [a[:]]
print(b)  # 输出: [[1, 2, 3]]

a.append(4)
print(b)  # 输出: [[1, 2, 3]]
```

在这个例子中，`b` 列表中存储的是 `a` 的一个副本，因此当 `a` 发生变化时，`b` 保持不变。









## 递归中的回溯

![image-20241102123927527](C:\Users\kivvii\AppData\Roaming\Typora\typora-user-images\image-20241102123927527.png)

```python
def quan(n, path, used, result):
    if len(path) == n:
        result.append(path[:])

    for i in range(1, n+1):
        if used[i]:
            continue

        used[i] = True
        path.append(i)

        quan(n, path, used, result)
        path.pop()
        used[i] = False


def pai(n):
    result = []
    used = [False] * (n + 1)
    quan(n, [], used, result)

    for i in result:
        print(" ".join(map(str, i)))


n = int(input())
pai(n)
```





#### maybe debug方法

静态查错->小黄鸭法，一行一行看代码，看就是了，假装向别人讲解

中间输出->不停地print

样例构造->自己构造样例，网站给的样例是最简单的嗯嗯，找一点苛刻的，1.边界 2.特殊条件，比如说是质数，考虑2  3.比给定样例更复杂的样例



#### debug常见错误

RE 运行时错误 （数组越界，运算错误除以零等等

TLE 超时 （可能出现死循环or搜索太慢了） MLE 内存超了

 错误的输出格式 检查空行，中英文，空格，大小写等等





#### 字典应该不能用.sort(),应该可以用sorted(字典)



## 字典的一个键可以对应一个列表，就可以对字典键对应的值进行求和







## 键错误

在 Python 中，如果在字典中查询一个不存在的键，会抛出一个 `KeyError` 异常。例如：

```
python复制代码my_dict = {'a': 1, 'b': 2}

# 查询一个不存在的键 'c'
print(my_dict['c'])
```

运行上述代码会抛出 `KeyError: 'c'`。

### 避免 KeyError 的几种方法

1. **使用 `in` 关键字检查键是否存在**

   ```
   python复制代码if 'c' in my_dict:
       print(my_dict['c'])
   else:
       print("键不存在")
   ```

2. **使用 `get` 方法** `get` 方法可以返回一个默认值，如果键不存在不会抛出异常。默认返回值是 `None`，也可以自定义。

   ```
   python复制代码print(my_dict.get('c'))        # 返回 None
   print(my_dict.get('c', '默认值'))  # 返回 '默认值'
   ```

3. **使用 `setdefault` 方法** `setdefault` 方法在键不存在时会把键添加到字典中，并设置一个默认值。

   ```
   python复制代码value = my_dict.setdefault('c', 0)  # 如果 'c' 不存在，则添加 'c': 0
   print(value)  # 输出 0
   ```

这几种方式可以帮助你在查询不存在的键时避免错误。





## 不能append map（）什么什么的，应为这只是append了一个映射对象，而不是数值



## 注意巧妙运用max和min来防止越界





## 两个集合可以取交集

```python
 set1 &= set2
```

表示集合一和集合二的i相同部分，当然也可以减去等等



## 不可以在min 和max里面这样子写sum，只能sum一个列表和sum遍历中的数值，而不是sum一个切片

![image-20241110113254829](C:\Users\kivvii\AppData\Roaming\Typora\typora-user-images\image-20241110113254829.png)

```python
max(c[i+1:][0]) #这么写包错的哈
```



## zip函数 将可迭代的对象合成元组

解释一下 `zip`：

- `zip` 是一个内置函数，它将多个可迭代对象打包成一个元组的迭代器。每个元组包含来自每个可迭代对象中的对应元素。 例如：

  python

  ```
  a = [1, 2, 3]
  b = [4, 5, 6]
  zipped = list(zip(a, b))
  print(zipped)  # 输出: [(1, 4), (2, 5), (3, 6)]
  ```





## 换行输出怎么写 换行是\n不是/n

## python

```python
print('\n'.join(map(str, ans)))
```

将所有测试用例的结果输出，每个结果占一行。







## 元组不可变，不能给元组赋值！！

![image-20241110152833415](C:\Users\kivvii\AppData\Roaming\Typora\typora-user-images\image-20241110152833415.png)





## 列表如何从后往遍历

你提到的 `for j in range(0, len(d) - 1, -1):` 这种写法实际上不会按你期望的方式工作。让我们详细分析一下：

### `range(start, stop, step)` 函数

- `start`：起始值（包含）
- `stop`：结束值（不包含）
- `step`：步长

### 分析 `for j in range(0, len(d) - 1, -1):`

- `start` 是 0
- `stop` 是 `len(d) - 1`
- `step` 是 -1

由于 `start` 小于 `stop`，而 `step` 是负数，这会导致 `range` 函数生成一个空的范围。因此，循环体内的代码不会被执行。

### 正确的从后往前遍历

要从后往前遍历一个列表或字典的键，可以使用以下几种方法：

#### 1. 使用 `reversed` 函数

python

深色版本



```
d = [0, 1, 2, 3, 4]
for j in reversed(range(len(d))):
    print(j)
```

#### 2. 使用 `range` 函数

python

深色版本



```
d = [0, 1, 2, 3, 4]
for j in range(len(d) - 1, -1, -1):
    print(j)
```

### 解释

- ```
  range(len(d) - 1, -1, -1)
  ```

  ：

  - `start` 是 `len(d) - 1`，即最后一个索引
  - `stop` 是 -1（不包含）
  - `step` 是 -1，表示从后往前遍历

### 示例

假设 `d` 是一个列表 `[0, 1, 2, 3, 4]`，那么：

python

深色版本



```
d = [0, 1, 2, 3, 4]
for j in range(len(d) - 1, -1, -1):
    print(d[j])
```

输出将是：



深色版本



```
4
3
2
1
0
```

### 对于字典

如果你需要从后往前遍历字典的键，可以先将键转换为列表，然后逆序遍历：

python

深色版本



```
d = {'a': 1, 'b': 2, 'c': 3}
keys = list(d.keys())
for key in reversed(keys):
    print(key, d[key])
```

输出将是：



深色版本



```
c 3
b 2
a 1
```

希望这能帮助你理解如何从后往前遍历列表或字典。如果有任何其他问题，请随时提问。



## 怎么在一个空列表中添加某个已知列表某索引后的所有字符

#### 1切片

```python
new_list = original_list[start_index:]
```

#### 2extend

```python
new_list.extend(original_list[start_index:])
```





## OJ里面f'’里面要是有单引号，外面就要用双引号，即f""







# 大小写字母与数字之间的转换 65 97

### 大写字母和数字之间的转换

1. **数字转换为大写字母**：

   - `chr(65 + 数字 - 1)`：将数字转换为大写字母，`65` 是字母 `A` 的 ASCII 值。

   python

   ```
   number = 1  # 比如转换数字1
   uppercase_letter = chr(65 + number - 1)
   print(uppercase_letter)  # 输出: A
   ```

2. **大写字母转换为数字**：

   - `ord(字母) - 65 + 1`：将大写字母转换为数字。

   python

   ```
   uppercase_letter = 'A'
   number = ord(uppercase_letter) - 65 + 1
   print(number)  # 输出: 1
   ```

### 小写字母和数字之间的转换

1. **数字转换为小写字母**：

   - `chr(97 + 数字 - 1)`：将数字转换为小写字母，`97` 是字母 `a` 的 ASCII 值。

   python

   ```
   number = 1  # 比如转换数字1
   lowercase_letter = chr(97 + number - 1)
   print(lowercase_letter)  # 输出: a
   ```

2. **小写字母转换为数字**：

   - `ord(字母) - 97 + 1`：将小写字母转换为数字。

   python

   ```
   lowercase_letter = 'a'
   number = ord(lowercase_letter) - 97 + 1
   print(number)  
   ```



## 判断是不是数字 用 .isdigit()

```python
while not s[pos].isdigit():
```



## divmod函数 取商取余数

`divmod` 是 Python 中的一个内置函数，用于同时计算两个数的商和余数。它返回一个包含商和余数的元组 `(quotient, remainder)`。

### 使用示例

假设我们有两个整数 `a` 和 `b`，我们想要计算 `a` 除以 `b` 的商和余数，可以使用 `divmod` 函数：

python

```python
a = 20
b = 3
quotient, remainder = divmod(a, b)
print(f"商: {quotient}, 余数: {remainder}")
```

## 正则表达式re的用法 match 检查是不是符合这个格式

```python
import re

def solve(s):
    # 判断输入字符串是否是"R<number>C<number>"格式
    if re.match(r'R\d+C\d+', s):
```



注意条件的奇怪表达

```python
while c:` 等价于 `while c > 0:
```





## 一维数组和二维数据的表示方式不同

一维数组 [0]*n

二维数组 [[401]*(n+2)] 

```
s=[[401]*(n+2)]
c= s+[[401]+[0]*n+[401] for i in range(n)]+s
```



## 100000的表示方式，其余同理

```python
n=int(1e5)
```

## 节省计算的函数只能用在 def上面



## break只能break掉一层循环，双层循环需要两个break，而且while k>0并不能起到限制的作用，因为是要内层循环都跑完才能再次到达while，所以再循环中必须加入条件判断

为了解决这个问题，你可以在内层循环中加入条件检查：

python

```python
while k > 0:
    for i in range(n):
        for j in range(i + 1, n):
            if k <= 0:
                break
            c[i][j] = c[j][i] = 1
            k -= 2
        if k <= 0:
            break
```

这种方式可以确保在 `k` 变成负数后，循环立即停止，而不是继续进行当前的所有迭代。

希望这个解释能帮助你理解代码中 `while` 循环的问题。如果有其他问题，随时告诉我！



## 将列表内的字符按空格分割打出

```python
print(*row)
```





## dfs dp都给我去pycharm上面看例题 bfs也是，其中小小的困惑见下,这个肯定会做cheat sheet

![image-20241120212643623](C:\Users\kivvii\AppData\Roaming\Typora\typora-user-images\image-20241120212643623.png)

## all()函数可以判断一个列表里是不是都是某个值，进行判断

## 例如 if all(all(x == False for b in x) for x in c): 



## 当e是一个列表，且e的值会在进行过程中变化，要用num.append((cnt, e.copy())) ，因为e是可变的。



dfs不用回溯

```python
import sys
sys.setrecursionlimit(20000)
def dfs(x,y):
    field[x][y]='.'
    for dx,dy in directions:
        nx,ny=x+dx,y+dy
        if 0<=nx<n and 0<=ny<m and field[nx][ny]=='W':
            dfs(nx,ny)

n,m=map(int,input().split())
field=[list(input()) for i in range(n)]
directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
cnt=0
for i in range(n):
    for j in range(m):
        if field[i][j]=='W':
            dfs(i,j)
            cnt+=1
print(cnt)

#用栈来模拟递归的过程，可以不用写开头那个，可以避免因递归过深而导致的栈溢出问题
def dfs(x,y):
    stack=[(x,y)]
    while stack:
        x,y=stack.pop()
        if field[x][y] != 'W':
            continue
        field[x][y]='.'
        for dx,dy in directions:
            nx,ny=x+dx,y+dy
            if 0<=nx<n and 0<=ny<m and field[nx][ny]=='W':
                stack.append((nx,ny))

n,m = map(int,input().split())
field =[list(map(int,input().split()))]
directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
cnt=0
for i in range(n):
    for j in range(m):
        if field[i][j] == 'W':
            dfs(i, j)
            cnt += 1
print(cnt)
```

dfs回溯

```python
#模板上的
n, m = map(int, input().split())
maze = [list(map(int, input().split())) for _ in range(n)]
# 定义⽅向
directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # 右、下、左、上
visited = [[False] * m for _ in range(n)] # 标记访问
max_path = []
max_sum = -float('inf') # 最⼤权值初始化为负⽆穷
# 深度优先搜索
def dfs(x, y, current_path, current_sum):
    global max_path, max_sum
# 到达终点，更新结果
    if (x, y) == (n - 1, m - 1):
        if current_sum > max_sum:
            max_sum = current_sum
            max_path = current_path[:]
        return
# 遍历四个⽅向
    for dx, dy in directions:
        nx, ny = x + dx, y + dy
# 检查边界和是否访问过
        if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
# 标记访问
            visited[nx][ny] = True
            current_path.append((nx, ny))
# 递归搜索
            dfs(nx, ny, current_path, current_sum + maze[nx][ny])
# 回溯
            current_path.pop()
            visited[nx][ny] = False
# 初始化起点
visited[0][0] = True
dfs(0, 0, [(0, 0)], maze[0][0])
# 输出结果
for x, y in max_path:
    print(x + 1, y + 1)
```

## bfs deque初始化问题

`q=deque([(x, y, start_height)])` 是一种将初始位置 `(x, y)` 和起始高度 `start_height` 存储在一起的方式。这里使用了 **元组** 来将多个值（`x`, `y`, `start_height`）打包在一起，再将这个元组作为队列中的一个元素。

### 解释为什么使用元组并放入队列

1. **`deque`**:
   - `deque` 是 Python 的一个双端队列，它允许从两端高效地插入和删除元素。它常用于广度优先搜索（BFS）或其他需要按顺序处理元素的数据结构。
   - 在 BFS 中，我们会将每个访问过的位置和相关的状态信息（如高度、时间、步数等）放入队列中，以便后续处理。
2. **为什么是元组**：
   - 元组是一个 **不可变** 的数据结构，意味着它的数据一旦创建就不能被修改。这样，它是一个更适合用于存储一组不可变信息（如 `(x, y, height)`）的容器。你可以在队列中保存这些元组，并确保队列中的每个元素始终是一个固定的三元组，避免意外修改。
   - 此外，元组还支持快速查找和比较，因此作为队列元素时，性能也很高。
3. **为什么要将 `(x, y, start_height)` 放到列表中**：
   - 这里的 `(x, y, start_height)` 是一个包含 **位置** 和 **起始高度** 的三元组。在 BFS 的过程中，我们需要同时记录当前位置（`x`, `y`）和与该位置相关的状态（如水位或高度，`start_height`）。将这些信息放在一起存储，可以方便地同时处理这些信息，而不需要分别维护多个队列或数据结构。
   - 比如，在 BFS 中你可能会不断处理队列中的每个元素，每次出队时都会获取当前的位置 `(x, y)` 和与之相关的状态（`start_height`）。这种方式使得算法的实现更加简洁和高效。
4. **列表套元组**:
   - 将元组放在列表中是为了初始化队列 `q`，这是因为 `deque` 需要一个 **可迭代** 对象作为初始化输入。`[(x, y, start_height)]` 是一个列表，里面包含一个元组。这样，队列 `q` 就初始化为一个包含一个元素的队列，元素是一个元组 `(x, y, start_height)`。



## 注意看，这个女人从来没有发现过的map的用法

`map(int, "110")` 会将字符串 `"110"` 中的每个字符 `'1'`, `'1'`, `'0'` 转换成整数，得到 `[1, 1, 0]`。



## 对数运算

在 Python 中，计算对数可以使用 `math` 模块提供的 `log` 函数。对数的常见形式有两种：自然对数（以 eee 为底）和以 10 为底的对数。

### 1. 自然对数（以 eee 为底）

要计算自然对数，使用 `math.log(x)`，其中 `x` 是你要取对数的数字。

```
python复制代码import math

x = 10
result = math.log(x)  # 默认以 e 为底
print(result)
```

### 2. 以 10 为底的对数

要计算以 10 为底的对数，使用 `math.log10(x)`。

```
python复制代码import math

x = 1000
result = math.log10(x)  # 以 10 为底
print(result)
```

### 3. 以任意底数的对数

如果你需要计算以其他数字为底的对数，可以使用 `math.log(x, base)`，其中 `base` 是你希望使用的底数。

```
python复制代码import math

x = 100
base = 2
result = math.log(x, base)  # 以 2 为底
print(result)
```

### 注意事项：

- 对数的输入 `x` 必须是正数。
- 底数 `base` 也必须是正数且不等于 1（即 base>0base > 0base>0 且 base≠1base \neq 1base=1）。

### 示例：

```
python复制代码import math

x = 8
# 以自然对数为例
print("自然对数:", math.log(x))  # 默认是以 e 为底

# 以 2 为底的对数
print("以 2 为底的对数:", math.log(x, 2))

# 以 10 为底的对数
print("以 10 为底的对数:", math.log10(x))
```

输出：

```python
makefile复制代码自然对数: 2.0794415416798357
以 2 为底的对数: 3.0
以 10 为底的对数: 0.9030902507885536
```

## 有时候dfs return True 只有里面的那一层，只有里面那一层会停止循环，还要在外面加一个return True 才可以

```python
def dfs(goal,y):
    if y==len(goal):
        return True
    for i in range(4):
        if goal[y] in c[i] and visited[i]==False:
            visited[i]=True
            if dfs(goal,y+1):
                return True
            visited[i]=False
    return False
```

## 非常容易错的

a和b是实时变化的，这样写不行

```python
a=max(a,b)#是错的
b=min(a,b)
```

## range操作 无论是倒着走还是正着走，都是实际开始的那个数放在前面，且前面是可以取到的。

```
for l in range(right,left-1,-1):
```

## heapq（greedy+queue）

`heapq` 默认会按照元组的第一个元素排序，而 `heapq.heappush(pos, (nx, ny, strength+...))` 会用 `nx` 作为优先级，这是不正确的。应该确保按 `strength` 排序。

`consumed` 是一个最小堆（`heapq` 实现的优先队列），用于存储已经饮用的药水效果。最小堆的特性是：

- 堆顶元素始终是 **当前饮用的药水中效果最小的那个**。
- 通过 `heapq.heappop`，可以高效地移除堆顶元素。

因此，`consumed[0]` 表示 **当前所有已饮用药水中效果最差的（数值最小的）药水**。

堆（堆顶在左，首位）

栈（栈顶在右，末尾） 后进先出，最后进来的最先pop出去

模板在这！

```python
import heapq

def max_potions(n, potions):
    # 当前健康值
    health = 0
    # 已经饮用的药水效果列表，用作最小堆
    consumed = []

    for potion in potions:
        # 尝试饮用当前药水
        health += potion
        heapq.heappush(consumed, potion)
        if health < 0:
            # 如果饮用后健康值为负，且堆中有元素
            if consumed:
                health -= consumed[0]
                heapq.heappop(consumed)

    return len(consumed)

n = int(input())
potions = list(map(int, input().split()))
print(max_potions(n, potions))
```

## 辅助栈和主栈的长度应该一致

```python
a=[]
m=[]
while True:
    try:
        s=input().split()
        if s[0]=='pop':
            if a:
                a.pop()
                if m:
                    m.pop()
        elif s[0]=='min':
            if m:
                print(m[-1])
        else:
            num=int(s[1])
            a.append(num)
            if not m:
                m.append(num)
            else:
                m.append(min(num,m[-1]))
    except EOFError:
        break
```

确保辅助栈 m 和主栈 a 长度一致是为了保持两者之间的同步性，这在处理 pop 操作时尤为重要。具体来说，这种做法有以下几个关键原因：

1. 同步移除
每当从主栈 a 中弹出一个元素时，我们也需要知道该操作是否会影响当前的最小值。如果辅助栈 m 的长度与主栈 a 不一致，那么在执行 pop 操作时，我们就无法准确地同步更新辅助栈的状态。通过保证两个栈的长度一致，我们可以确保每次 pop 操作都能正确地从两个栈中移除对应的元素。

2. 正确反映历史最小值
假设我们不重复添加当前最小值，而是只在新元素小于或等于当前最小值时才更新辅助栈。在这种情况下，当我们连续插入多个相同的最小值（例如，连续插入多个 3），然后开始弹出这些元素时，辅助栈将不能准确反映这些操作的历史。例如：

插入 5, 3, 3, 3
辅助栈会是 [5, 3] 而不是 [5, 3, 3, 3]
当第一次 pop 操作移除一个 3 后，辅助栈变为 [5]，这暗示着下一个最小值是 5，但实际上还有两个 3 在主栈中。因此，为了确保辅助栈能正确反映每个状态下主栈中的最小值，我们需要在每次插入时都更新辅助栈，即使新元素并不改变当前的最小值。

3. 简化逻辑
通过总是将当前最小值推入辅助栈，我们可以简化逻辑并避免复杂的条件判断。无论新元素是否改变了最小值，我们都执行相同的操作，这使得代码更容易理解和维护。





### **普通 Dijkstra 的特点**

普通 Dijkstra 算法有一个重要前提：

- 从一个节点到达另一个节点的代价是固定的，且代价只会累积、不会减少（例如距离、时间等）。

- 这使得 **首次以最小代价从堆中弹出的节点，一定是全局最优路径到达该节点**。

- 因此，一旦一个节点被访问（`visited`），后续路径再访问这个节点就一定不是更优路径，可以安全忽略。

- 

- ```python
  import heapq
  n=int(input())
  land=[]
  dir=[[0,1],[0,-1],[1,0],[-1,0]]
  for i in range(n):
      land.append(input())
  visited=[[True]*(len(land[i])) for i in range(len(land))]
  def find(x1,y1):
      pos=[]
      heapq.heappush(pos,(0,x1,y1))
      visited[x1][y1]=False
      while pos:
          step,x,y=heapq.heappop(pos)
          #print(step,x,y)
          if land[x][y]=="1" and step!=0:
              return step
          for dx,dy in dir:
              nx,ny=x+dx,y+dy
              if 0<=nx<n and 0<=ny<len(land[nx]) and visited[nx][ny]:
                  visited[nx][ny]=False
                  if land[nx][ny]==land[x][y] and land[x][y]!="0":
                      heapq.heappush(pos,(step,nx,ny))
                  else:
                      heapq.heappush(pos,(step+1,nx,ny))
  mark=False
  for i in range(n):
      for j in range(len(land[i])):
          if land[i][j]=="1":
              print(find(i,j)-1)
              exit()
  ```

------

### **本题的特殊性**

本题的路径代价计算方式是 **“移动后高度差的绝对值”**，这带来了以下问题：

1. **路径代价的动态性**

   - 每次移动的体力消耗与当前节点和目标节点的高度差有关。
   - 高度差的绝对值可能因为不同路径的到达顺序而变化。
   - 这意味着，从不同方向进入同一个节点 `(x, y)` 时，路径消耗可能不同。

2. **不同路径可能带来不同消耗**

   - 如果强制使用 `visited` 标记，每个节点只允许被访问一次，则可能忽略从另一条路径到达该节点的更优解。

   - 举例：
     在以下场景中，目标是到达右下角 `(1, 2)`：

     ```
     复制代码高度图：
     1 2 3
     1 1 3
     ```

     初始状态在 `(0, 0)`，从两条路径走向 `(1, 2)`：

     - 路径 1：`(0, 0) -> (0, 1) -> (0, 2) -> (1, 2)`，消耗体力为 `1+1+2=4`。
     - 路径 2：`(0, 0) -> (1, 0) -> (1, 1) -> (1, 2)`，消耗体力为 `0+0+2=2`。

     如果路径 1 先到达 `(1, 2)`，标记为已访问，则路径 2 的更优解会被错误忽略。

3. **不能假设首次到达即为最优**

   - 由于路径代价动态依赖于高度差，不能简单依赖首次访问原则。

     ```python
     import heapq
     m, n, p = map(int, input().split())
     martix = [list(input().split())for i in range(m)]
     dir = [(-1, 0), (1, 0), (0, 1), (0, -1)]
     for _ in range(p):
         sx, sy, ex, ey = map(int, input().split())
         if martix[sx][sy] == "#" or martix[ex][ey] == "#":
             print("NO")
             continue
         in_queue, heap, ans = set(), [], []
         heapq.heappush(heap, (0, sx, sy))
         in_queue.add((sx, sy, -1))
         while heap:
             tire, x, y = heapq.heappop(heap)
             if x == ex and y == ey:
                 ans.append(tire)
             for i in range(4):
                 dx, dy = dir[i]
                 x1, y1 = dx+x, dy+y
                 if 0 <= x1 < m and 0 <= y1 < n and martix[x1][y1] != "#" and (x1, y1, i) not in in_queue:
                     t1 = tire+abs(int(martix[x][y])-int(martix[x1][y1]))
                     heapq.heappush(heap, (t1, x1, y1))
                     in_queue.add((x1, y1, i))
         print(min(ans) if ans else "NO")
     ```

------

### **为什么其他 Dijkstra 可以直接 `visited`？**

1. **固定代价**
   在经典 Dijkstra 问题中，路径代价是固定的，无论从哪个方向到达节点，其代价都相同。
2. **单次访问即最优**
   - 经典 Dijkstra 算法中，每个节点的首次访问代价是从起点到该节点的最小代价，因此可以直接标记为访问。
3. **单一优先队列逻辑**
   - 普通 Dijkstra 中不需要处理动态代价调整问题。

------

### **如何解决这个问题？**

为了解决这一问题，必须允许 **同一个节点从不同路径入堆**，从而确保计算出全局最优路径。这有两种主要方法：

1. **方向标记法（他的代码实现）**
   - 使用 `(x, y, direction)` 作为访问标记，区分从不同方向进入同一个点的情况。
   - 这样可以确保每次入堆都记录了完整的路径信息，不遗漏更优解。
2. **多次入堆法（简化代码）**
   - 不使用方向标记，允许同一个节点多次入堆。
   - 因为堆的性质，最优解会优先出堆，当一个节点的最优路径确定后，后续更高代价的路径会自然被跳过。

------

### **总结**

- **本题需要考虑从不同地方入堆的根本原因**：路径代价依赖于动态的高度差，不同路径可能带来不同代价。
- **普通 Dijkstra 不需要考虑的原因**：路径代价固定，首次访问即为最优。

解决方法可以通过方向标记或允许多次入堆实现。

### 切片操作 a[::-1]

在 Python 的切片语法 sequence[start:stop:step] 中：

start：指定切片的起始索引，默认是序列的开头。
stop：指定切片的结束索引（不包含），默认是序列的结尾。
step：指定切片的步长，默认是 1（表示按顺序取元素）。如果设置为负数，则表示逆序取元素。

### 小数的打法

print(f"{num:.2f}")可以输出保留两位小数的num

### defaultdict的用法

```python
from collections import defaultdict

# 语法: defaultdict(默认值工厂函数)
d = defaultdict(int)  # 默认值为整数 0
```

```python
from collections import defaultdict
from itertools import permutations

a = defaultdict(int)
b = defaultdict(int)
c = defaultdict(int)
d = defaultdict(int)
n = int(input())

for i in input():
    a[i] += 1
for i in input():
    b[i] += 1
for i in input():
    c[i] += 1
for i in input():
    d[i] += 1

dicts = [a, b, c, d]

def check(word):
    for perm in permutations(dicts, len(word)):
        for i, d in enumerate(perm):
            if word[i] not in d:
                break
        else:
            return 'YES'
    else:
        return 'NO'

for _ in range(n):
    word = input()
    print(check(word))
```

Kadane's algorithm



### Kadane's 算法是⼀种⽤于解决最⼤⼦数组问题（Maximum Subarray Problem）的⾼效算法

```python
def max_subarray_sum(arr):
    if not arr:
        return 0
    max_current = max_global = arr[0]
    for num in arr[1:]:
        max_current = max(num, max_current + num)
        if max_current > max_global:
            max_global = max_current
        return max_global
# 测试⽤例
arr = [-2, 1, -3, 4, -1, 2, 1, -5, 4]
print("最⼤⼦数组和为:", max_subarray_sum(arr)) # 输出: 最⼤⼦数组和为: 
```



## 小数的打法

```
f'{num:.1f}'
```
